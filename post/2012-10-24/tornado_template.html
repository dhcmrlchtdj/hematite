<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width">
<title>开始造轮子吧</title>
<link rel="stylesheet" href="https://raw.github.com/necolas/normalize.css/master/normalize.css" />
<link rel="stylesheet" href="../../theme/static/css/common.css" />
</head>
<body>
<header>
<h1>涂鸦</h1>
</header>
<nav>
<ul>
<li><a href="../../index.html" title="index">INDEX</a></li>
<li><a href="../../tag.html" title="tag">TAG</a></li>
<li><a href="../../link.html" title="link">LINK</a></li>
<li><a href="../../about.html" title="about">ABOUT</a></li>
</ul>
</nav>
<article id="post">
<h1>开始造轮子吧</h1>
<p>想着重复造个轮子，自己写一个模板系统，之前以为不是很难，
现在发现完整实现一个模板还是相当复杂的。</p>
<p>断断续续看了两天，才把<code>tornado.template</code>的整体结构都搞明白。剩下一些细节，
等之后再研究了，先把看懂的记下来。基本是照着我自己看代码的顺序，再整理了一下。</p>
<p>最开始的想法就是写一个<code>Template</code>类，读取模板，然后替换，最后输出。
开始连是传入文件路径还是字符串都没考虑好，乱七八糟的东西不提也罢，
直接开始研究 tornado。</p>
<h2>使用 tornado.template</h2>
<div class="codehilite"><pre><span class="c"># tornado 中 Template 类的使用</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="s">&quot;&lt;html&gt;{{ myvalue }}&lt;/html&gt;&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">t</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">myvalue</span><span class="o">=</span><span class="s">&quot;XXX&quot;</span><span class="p">)</span>

<span class="c"># tornado 中 Loader 类的使用</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">Loader</span><span class="p">(</span><span class="s">&quot;/home/btaylor&quot;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">loader</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&quot;test.html&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">myvalue</span><span class="o">=</span><span class="s">&quot;XXX&quot;</span><span class="p">)</span>
</pre></div>


<p>要在非 tornado 的应用中使用 tornado 的模板，上面就是基本用法了。
<code>Template</code>类接受字符串，然后替换输出。而<code>Loader</code>类接受的是路径，
读取路径下的模板文件，替换输出。很明显，调用<code>load</code>方法应该是生成了一个
<code>Template</code>的实例。</p>
<p>要注意的一点，在自己的程序中使用 tornado 的模板时，
如果直接用字符串实例化<code>Template</code>，是不支持<code>extends</code>之类的语句的。
多个模板文件的情况下，应该使用<code>Loader</code>。</p>
<p>使用 tornado 写 web 应用时，不用自己调用<code>Loader</code>，
程序会自动加载<code>settings['template_path']</code>，
直接使用<code>tornado.web.RequestHandler</code>的<code>render</code>方法就可以了。</p>
<h2>tornado.template 的实现</h2>
<p>接下来研究具体实现。开始没看仔细，说明文档在第一行就说了，
tornado 的模板实现是把模板文件编译成 python 代码，再执行这个代码，
基本上把代码看完了，才知道是这样。
（A simple template system that compiles templates to Python code.）</p>
<h3>Loader</h3>
<p>首先是<code>Loader</code>的实现。代码还算简单。主要就做了一件事情，读取路径。
为了提高解析模板的效率，<code>Loader</code>的实例有个<code>template</code>属性，以模板名为关键字，
保存着编译好的模板实例。每次读取模板，都是在这个<code>template</code>中读取，
如果没有编译好的模板，<code>Loader</code>实例会生成相应的模板，保存在该属性中。
由于每次读取<code>template</code>时，可能会往里面添加新的模板，
所以 tornado 在每次读取时都会加锁（<code>threading.RLock()</code>），避免发生重复编译。</p>
<p>另外值得一提的是<code>Loader</code>不检查文件路径是否存在，
文件不存在的错误在<code>open</code>试图读取文件是抛出的。
还有<code>open</code>是将模板文件当作二进制文件读取的，我自己试了下，当作二进制文件读取，
返回的是<code>bytes</code>类型，而当作文本文件读取，返回的是<code>str</code>类型。
tornado 的模板实现里，进行了多次的字符串类型转换，这个等之后再具体研究。</p>
<h3>Tempalte</h3>
<p>在生成实例化<code>Tempalte</code>的时候，对模板的编译就完成了，
也就是说已经生成了 python 代码，剩下的只是执行和输出。
大部分工作在<code>__init__</code>中就完成了，下面挑要点来讲。</p>
<p><code>__init__</code>中有个<code>reader</code>属性，这是<code>_TempalteReader</code>的实例，用于读取模板文件。</p>
<p>之后执行了<code>_parse(reader, self)</code>，<code>_parse</code>用于解析模板文件，将模板内容分块，
然后用这个执行结果实例化一个<code>_File</code>类。</p>
<p>接下来调用<code>_generate_python</code>就是将这些块转换成相应的 python 代码，
把代码保存在了<code>self.code</code>属性中。</p>
<p>接下来就是编译生成的 python 代码，并保存在<code>self.compiled</code>属性里。</p>
<p>实例化的工作到此结束。</p>
<p>在输出也就是调用<code>generate</code>方法时，tornado 将用户变量保存在一个命名空间里，
在命名空间中执行刚才编译好的 python 代码，执行的结果是生成一个<code>_execute</code>函数，
执行该方法，就输出了模板。</p>
<hr />
<p>知道了大致流程，下面一点点具体研究。</p>
<h4>_TempalteReader</h4>
<p><code>_TempalteReader</code>类用于实现读取文件内容，<code>find</code>方法来查找字符位置，
<code>consume</code>方法返回读取的字符串，<code>__getitem__</code>实现了取某个位置的字符，
即<code>reader[key]</code>。</p>
<h4>_parse</h4>
<p><code>_parse</code>方法用于解析文件内容。将结果保存在一个<code>_ChunkList</code>实例中，
当作列表理解就可以了。</p>
<p>就流程来说，先判断文件是否结束，结束就返回。然后根据模板的语法，先寻找<code>{</code>，
将<code>{</code>之前的文件内容保存为文本块（<code>_Text</code>）。
然后判断<code>{</code>的类型，转义（<code>{{!</code>）会保存为文本块，注释（<code>{#</code>）则直接丢弃，
直接输出的变量（<code>{{</code>）保存为语句块（<code>_Expression</code>）。</p>
<p>接下来是对其他语法的处理，对于<code>apply</code>、<code>block</code>、<code>try</code>、<code>if</code>、<code>for</code>、<code>while</code>
这几个要跟<code>end</code>成对使用的语句，采用了递归处理的办法。
用剩下的内容调用<code>_parse</code>，遇到<code>end</code>时返回解析结果。</p>
<p>其他语句也差不多，就是顺序执行，没仔细看，就先分析到这里。</p>
<h4>_File</h4>
<p>第一个参数是<code>Tempalte</code>实例，第二个参数是<code>_ChunkList</code>实例。
编译出来的 python 代码只有一个<code>_execute</code>函数，就是<code>generate</code>方法生成的。
这个方法遍历整个<code>_ChunkList</code>，调用各个块的<code>generate</code>方法，
生成完整的<code>_execute</code>。</p>
<h4>_generate_python 和 _get_ancestors</h4>
<p>从名字就知道<code>_generate_python</code>用于生成 python 代码。
<code>_generate_python</code>先调用<code>_get_ancestors</code>，
在返回的<code>_File</code>实例中查找<code>_ExtendsBlock</code>，也就是查找父模板，这是一个递归过程，
直到找到最初的模板，返回模板列表，列表是子模板到父模板的顺序。
之后将模板列表逆序，递归查找其中的<code>_NamedBlock</code>块（即<code>block</code>语句），
将找到的块保存在变量中。</p>
<p>简单解释一下，这个过程其实是完成模板的继承。
首先找到父模板，然后查找父模板的<code>block</code>块，保存在变量<code>named_block</code>中。
再查找子模板的<code>block</code>块，同样保存在<code>named_block</code>中，并且会覆盖父模板的同名块。
这就实现了父模板中<code>block</code>有默认值，而子模板的<code>block</code>会覆盖相应的值。</p>
<p>之后<code>_generate_python</code>实例化一个<code>_CodeWriter</code>，父模板调用<code>generate</code>方法，
将各个块转换成 python 代码。</p>
<p>注意下，父模板的<code>template</code>属性和<code>generate</code>方法都是从<code>_File</code>继承来的。</p>
<h4>_CodeWriter</h4>
<p>python 使用缩进，所以<code>_CodeWriter</code>的一项任务就是保证输出的代码中缩进正确。
此外还实现了一个栈，用于<code>_IncludeBlock</code>块，还没搞明白。</p>
<h3>rest</h3>
<p>剩下的就是一个语法错误类和各个块的实现，还没看完。所以就到此为止了。</p>
<h2>拓展阅读</h2>
<p>这是中午偶然找到的文章，
<a href="http://pocoo.org/~mitsuhiko/codegenjinja.pdf">Code Generation in Python — Dismantling Jinja</a>，
来自 pocoo 的 Armin Ronacher。</p>
<p>其实还有好几个地方要再仔细看下，特别是编码的问题。
之后应该还会看一下 js 的模板怎么实现。所以应该还会写点相关的文章。</p>
<p>关于重复造轮子的问题，不管怎么样，先看懂别人怎么造轮子再说吧。</p>
</article>
<footer></footer>
</body>
</html>
