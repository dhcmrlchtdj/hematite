<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width">
<title>python 中异步处理</title>
<link rel="stylesheet" href="https://raw.github.com/necolas/normalize.css/master/normalize.css" />
<link rel="stylesheet" href="../../theme/static/css/common.css" />
<link rel="alternate" type="application/rss+xml" href="../../feed" title="Feed">
</head>
<body>
<header>
<h1>涂鸦</h1>
</header>
<nav>
<ul>
<li><a href="../../index.html" title="index">INDEX</a></li>
<li><a href="../../tag.html" title="tag">TAG</a></li>
<li><a href="../../link.html" title="link">LINK</a></li>
<li><a href="../../about.html" title="about">ABOUT</a></li>
</ul>
</nav>
<article id="post">
<h1>python 中异步处理</h1>
<p>为了提高 yuedu.py 的下载速度，跑去鼓捣异步请求。
从写上一篇文章到现在，课余时间都花在这上面了。</p>
<p>先说下为什么又自己造轮子了……</p>
<ul>
<li>考虑过学习下 gevent，结果发现不支持 python3。</li>
<li>gevent 是基于 greenlet 的，而且 greenlet 支持 python3。
    可是不太明白怎么进行异步处理，而且发现了更好的东西。</li>
<li>tornado 可以进行异步请求。但是 pycurl 不支持 python3，所以没法使用 curl 了，
    其实还有个非 pycurl 的默认异步请求工具，在发现了下面这东西后直接放弃了。</li>
<li>python 标准库里的 asyncore，虽然是自己操作请求，但写起来超级简单，
    所以有大约三分一时间，都是花在了这上面。可惜只能用 select 或者 poll，
    所以我最后也放弃了。</li>
</ul>
<p>放弃 asyncore 之后，我就直接自己动手写了。就当是学习使用 epoll 吧。</p>
<p>帮助最大的是这篇文章<a href="http://scotdoyle.com/python-epoll-howto.html">How To Use Linux epoll with Python</a>，
网上有中译，直接看代码也很好理解。
文章里面还有个链接<a href="http://www.jmarshall.com/easy/http/">HTTP Made Really Easy</a>，
我自以为翻过几页 <em>HTTP: The Definitive Guide</em>，对请求长什么样还算清楚，
就没仔细看。结果吃了不少亏，要是当初完整看一遍，
就不会被<code>Transfer-Encoding: chunked</code>搞得焦头烂额了。</p>
<hr />
<p>题目虽然叫什么异步处理，实际上没什么可写的。
关于套接字还有并行的基础知识，可以看 <em>CSAPP</em> 后三章，
再去翻一翻 <em>UNIX 网络编程</em> 就可以了。
epoll 基础看上面链接的文章，配合官方文档就可以开始写程序了。</p>
<p>下面写一点自己的心得。</p>
<ul>
<li>collections.namedtuple 挺好用的。</li>
<li>socket.setblocking(0) 进行非阻塞请求。</li>
<li>服务端设置<code>backlog</code>时，可以用<code>socket.SOMAXCONN</code>。</li>
<li>可以用 sendall 直接把所有请求发出去，我还是自己一点点 send 的。</li>
<li>recv 接收的字节数应该是 2 的幂，文档推荐可以每次接受 8192 个字节，
    其实大部分时候都没这么多。</li>
<li>请求的请求头有几个值必须设置，否则请求经常被重定向什么的，参考上面那篇链接。</li>
<li>请求写 HTTP/1.1 的话，要处理<code>Transfer-Encoding: chunked</code>等情况，
    我自己写的程序其实还没完全搞定，只算是勉强可用了。</li>
<li>返回的<code>Set-Cookie</code>可能会有多个，不知道还有没有类似的情况。
    准备自己写个 Headers 类处理，又碰到兼容 dict 的问题，要实现好几个接口。</li>
<li>设置个重定向次数上限，避免出现死循环，wiki 上推荐是 5 次。</li>
<li>用个 try 语句来关闭 epoll 和打开的套接字。</li>
<li>可以在请求时才生成 epoll 和套接字，也就是惰性求值，避免套接字没有正常关闭。
    这样做也有个缺点，为了能够在回调函数中添加任务，
    就要在每次循环时检查是否有新任务加入。
    想避免检查的开销，不用惰性求值，而是直接在每次添加任务时创建套接字，
    又可能出现套接字或 epoll 最后没正常关闭的情况。</li>
<li>在读取写入都完成后，要关闭套接字（shutdown），否则 epoll 不会停止。</li>
<li>ssl 的非阻塞请求要设置<code>do_handshake_on_connect=False</code>。</li>
<li>读取 ssl 时，要检查读写错误，文档有说明。可以自己重写 recv 方法，
    也可以在循环里面处理。我觉得重写个方法更符合逻辑。</li>
</ul>
<hr />
<p>先写到这里，刚刚发现了个<a href="http://code.google.com/p/tulip/">好东西</a>。准备好好研究一下。</p>
<p>另外，虽然不是异步，标准库里的<code>concurrent.futures</code>很容易上手。
之前使用过，不过效率的提升不大（不明显？）。</p>
</article>
<footer></footer>
</body>
</html>
