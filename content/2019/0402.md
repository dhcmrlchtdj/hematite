+++
date = '2019-04-02'
title = '小程序'
tags = ['code']
+++

[这篇文章](https://www.infoq.cn/article/ullETz7q_Ue4dUptKgKC) 讲了不少小程序的优化，这里做点记录。

## 渲染层和逻辑层

先扯点题外话，我对小程序一直有个疑惑，为什么要把逻辑层和渲染层分开？
如果是 [ReactNative](https://facebook.github.io/react-native/docs/performance) 这种架构，那么分层是可以理解的，毕竟 UI thread 根本不执行 JS。
但不管是微信还是支付宝，小程序都运行在 webview 环境下，这样的分层是在人为增加了进程间通信的成本啊。

[这篇文章](https://caelumtian.github.io/2018/09/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/) 也谈及了这点，不过结论也仅是作者的推测。
通过这样的分层，隔离了渲染和逻辑，让渲染的代码更轻量，不会出现 UI 卡顿。
但通信成本高了啊，比如 RN 一样会有响应不及时的问题。

一个同事给我说的是，微信小程序最先是 RN 做底层，之后为了满足一些渲染需求，又换成了 webview，但是保留了 RN 这种分离的架构。
[这里](https://www.infoq.cn/article/2017/10/wangyue-interview) 也提到了这种“坊间传说”，不知道是不是真的。


## 通信优化

前面那篇小程序架构的文章里，就提到了 UI/JS 两个进程的通信优化，直接让 UI/JS 两个进程共享部分内存。
这个没有一定的底层开发能力，学不来啊……
共享内存节省了序列化反序列化的开销，如果是 RN 的架构，这种玩法反而不行了。
不过反过来说，就是因为是 JS，所以序列化才慢吧……

记得之前 RN 也说要优化两个进程的通信，文章找不到了……

~~我觉得 glimmer-vm 的思路是比较棒的，直接将操作变成指令，数据同步的开销变小，也没有共享内存带来的风险。~~
上面这句不太对。
在小程序的架构下，通信的是 setData 调用和事件。
序列化的开销是数据，和优化模版表示不太相关。


## 首屏优化

首屏优化的思路是复用上一次的渲染结果。

之前写 feedbox 的时候，是在 service worker 缓存 template 和 API，使用上次访问的数据进行渲染。
数据更新后没有提示，要等用户下次访问才生效。

支付宝这个做得更完善，存储的是 VDOM，没有再次组合数据的开销，可以直接渲染。
数据更新后，会更新页面，保证用户看到新的数据。

这种做法，我觉得在大部分场景都是适用的。
配合产品逻辑做一些提示，用户体验应该也能满足要求。
实时性要求非常高，同时要求很好的首屏性能，可能只能走服务端渲染的方式了。

## WASM 优化 VDOM

没看过源码，所以只是猜想。
在 RN 里面，UI 进程的输入是 VDOM，生成 VDOM 的过程是在 JS 进程实现的。
而在小程序里面，UI 进程的输入是 DATA，生成 VDOM 的过程是在 UI 进程实现的。

RN 里面能不能用 WASM 优化 VDOM 的生成呢？
我觉得难度是比较高的，等于是要把 JS 转换成 WASM。

而小程序里面，不管微信的 wxs 还是支付宝的 sjs，都是 ES5 的子集。
不过即使是 ES5 的子集，支付宝如何将其转换成 WASM，感觉还是很厉害啊。
或者是我的理解不太对，因为文中还提到 typescript 的类型传递给 WASM 引擎。
所以是将一些 VDOM 计算逻辑改成 WASM 实现？

不管怎么样，这里的底层优化能力，还是很佩服的。
