+++
date = '2019-04-21'
title = 'ocaml ppx'
tags = ['ocaml']
+++

rust con 上有两个主题都涉及了 rust 的 procedural macro。
想起了 ocaml 的 ppx，想到了，那就写一写。

---

[deriving](https://github.com/ocaml-ppx/ppx_deriving) 是比较常用的一个 ppx 库。
比如下面这个例子，会 rust 的看着像 rust，会 haskell 的看着像 haskell。
（大概，没有人是先会 ocaml 的 😂

```ocaml
type point3d = float * float * float
[@@deriving show]
```

那么，这个 `@@deriving` 是怎么实现的呢？
官方文档里只有寥寥数语，[Attributes](https://caml.inria.fr/pub/docs/manual-ocaml-4.08/manual035.html)、[Extensions](https://caml.inria.fr/pub/docs/manual-ocaml-4.08/manual036.html)，这个文档，大概没人能看明白……
这种时候，就只能靠社区写的工具和教程了……

其实 ppx/macro 也还是一个函数，输入 ast 输出 ast，写之前先想明白要做什么就可以了。
调试的话，最粗暴的就是打印看下是否符合预期，不过好像也没有不粗暴的方法？
比如前面的例子，输出的代码是这样的

```ocaml
(* ocamlfind ocamlc -dsource -linkpkg -package ppx_deriving.std point3d.ml *)
type point3d = float * float * float [@@deriving show]

let rec (pp_point3d : Format.formatter -> point3d -> Ppx_deriving_runtime.unit)
    =
    (let open! Ppx_deriving_runtime in
     fun fmt (a0, a1, a2) ->
         Format.fprintf fmt "(@[";
         (Format.fprintf fmt "%F") a0;
         Format.fprintf fmt ",@ ";
         (Format.fprintf fmt "%F") a1;
         Format.fprintf fmt ",@ ";
         (Format.fprintf fmt "%F") a2;
         Format.fprintf fmt "@])") [@ocaml.warning "-A"]


and show_point3d : point3d -> Ppx_deriving_runtime.string =
    fun x -> Format.asprintf "%a" pp_point3d x
```

---

学 ppx 入门例子是 `ppx_getenv`，从 [硬怼 AST](https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/) 到 [社区沉淀了一些工具](http://rgrinberg.com/posts/extension-points-3-years-later/) ，再到工具整合成 [ppxlib](https://github.com/ocaml-ppx/ppxlib/blob/master/HISTORY.md)。
`ppx_getenv` 会将 `let user = [%getenv "USER"]` 改写成 `let user = Some("h11")`，在编译时计算了 `Sys.getenv_opt "USER"`。

```ocaml
open Ppxlib
module Ast_builder = Ppxlib.Ast_builder.Default
module Ast_pattern = Ppxlib.Ast_pattern
module Extension = Ppxlib.Extension
module Driver = Ppxlib.Driver

let name = "getenv"

let expander ~loc ~path:_ (env : string) =
    match Sys.getenv_opt env with
        | None ->
            [%expr None]
        | Some s ->
            (* https://github.com/ocaml-ppx/ppxlib/blob/0.6.0/src/ast_builder_intf.ml#L7 *)
            let es = Ast_builder.estring ~loc s in
            [%expr Some [%e es]]

let ext =
    let context = Extension.Context.expression in
    let pattern = Ast_pattern.(single_expr_payload (estring __)) in
    (* https://github.com/ocaml-ppx/ppxlib/blob/0.6.0/src/extension.mli *)
    Extension.declare name context pattern expander

let () = Driver.register_transformation name ~extensions:[ext]

(* https://github.com/ocaml-ppx/ppxlib/blob/0.6.0/src/driver.mli#L167 *)
let () = Driver.run_as_ppx_rewriter ()
```

上面这个代码还算好理解，就是 API 文档缺失，自己翻代码吧……
之后把 ppx 编译好就能使用了

```
$ ocamlfind ocamlc getenv.ml -package ppxlib -package ppxlib.metaquot -linkpkg -o getenv.ppx
$ ocamlc get-user-example.ml -ppx './getenv.ppx' -dsource
```

至于怎么匹配到 `[%getenv "USER"]`、怎么拿到的 `"USER"`，这些细节都被 ppxlib 处理了。
expander 里可以写些什么语句，可以查看 [metaquot](https://ppxlib.readthedocs.io/en/latest/ppx-for-plugin-authors.html#metaquot)。

---

回到最初的例子，`deriving_eq` 要怎么实现呢？
首先，输入是类型申明，输出是 `eq_type-name` 函数。
（好了好了，ad hoc polymorphism 没有就没有了，不要喷了。

其次，`deriving_eq` 是放在类型申明后面，所以要实现的是 `item-attribute`。
不知道什么是 `item-attribute`？官方文档。
简单讲，`extension` 是语法上的占位符，比如前面用 `[%getenv "USER"]` 代替 `Some(user)`，就是 `extension` 代替了 [`expr`](https://caml.inria.fr/pub/docs/manual-ocaml-4.08/expr.html#expr)。
而 `attribute` 类似注解，修饰原本完整的语句。`type point3d = float * float * float` 本身是完整的，我们只是加上标识，方便之后做展开。

通过 `ocamlc -dparsetree point3d.ml` 的输出，我们可以知道要处理的是 `type_declaration`。

```ocaml
open Ppxlib
module Ast_pattern = Ppxlib.Ast_pattern
module Attribute = Ppxlib.Attribute
module Driver = Ppxlib.Driver

let name = "deriving_eq"

let k x = x

let attr =
    (* ocamlc -dparsetree point3d.ml *)
    let context = Attribute.Context.type_declaration in
    let pattern = Ast_pattern.__ in
    (* https://github.com/ocaml-ppx/ppxlib/blob/0.6.0/src/attribute.mli#L76 *)
    Attribute.declare name context pattern k

let () = Driver.register_transformation name ???

(* https://github.com/ocaml-ppx/ppxlib/blob/0.6.0/src/driver.mli#L167 *)
let () = Driver.run_as_ppx_rewriter ()
```

其他部分写不出来了，ppxlib 文档太少……
