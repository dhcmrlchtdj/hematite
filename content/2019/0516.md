+++
date = '2019-05-16'
title = 'V8 GC'
tags = ['v8', 'gc']
+++

> Most of these algorithms and optimizations are common in garbage collection literature and can be found in many garbage collected languages.
> But state-of-the-art garbage collection has come a long way.

GC 的概念很容易理解，但成熟的实现是什么样的呢？

---

后面主要讲 tracing GC，这里就先提一下引用计数。

首先，我认为 RC 属于 GC，和 tracing 一样不需要用户关注内存分配及回收。
难道会有人认为 cpython 没有 GC 吗?

然后，不做条件限制的话，我觉得 tracing 比 RC 更好。
如果出现大量节点接连释放，不见得暂停时间就短。
如果对计数操作进行延迟处理，和 tracing 就更接近了。
RC 要引入其他手段处理循环引用，类比的话，就像语言不能自举？

RC 的优势，可能是更容易和外界配合？
不太确定，争取后续搞明白。

---

先明确几个概念。

- generational
    - 几乎所有现代的 GC 都做了分代
    - young 用 copying，old 用 mark-compact，也是非常常见的模式
- incremental
    - 用户代码和 GC 交替进行
    - 减少 GC 造成的延迟
- parallel
    - stop-the-world
    - 同时有几个线程在执行 GC 操作
- concurrent
    - 一个线程执行用户代码，其他线程执行 GC 操作
    - 完全不阻塞用户代码

这里 parallel 和 concurrent 的区别，来自 V8 blog。
这和用户代码自身的并发、并行并不完全一样。
不扣字眼，理解下这种场景就好。

---

### young / copying

- Cheney's algorithm，所有 GC 的资料都会提到，一个 BFS 的遍历，简单实用。
- BFS 过程居然可以和 tri-color marking 等价，之前没意识到呐。
- V8 之前也在用，后来改成了 parallel 的其他算法

---

### old / mark-compact

- 主要是 mark 阶段，进行了 incremental/parallel/concurrent 改造（对，三种都搞了
    - mark 是大头，sweep/compact 的暂停时间比 mark 要短
- tri-color marking，黑灰白
    - 对象从 young 移动到 old 的时候，会直接标记为 black，直接跳过一轮 GC。这和分代一样属于实际经验吧。
- incremental marking 靠 write barrier 实现
    - V8 里用的是 Dijkstra-style write-barrier
    - 每次执行 `obj.field = value` 这种语句，都插入额外检查
    - 网页的逻辑包含大量事件驱动，会有很多空闲（idle）状态，很适合插入 incremental marking
    - nodejs 这类服务端逻辑，就没有这种空闲状态了
- parallel marking 靠多线程加快 marking 速度
    - 仍然是 stop-the-world，所以对象的 marking 状态不会变化，不需要各种 barrier
    - 关键是 worklist 的结构如何支持多线程操作，要线程安全、要高效
- concurrent marking 过程中要考虑各种 data race
    - worker 线程在 marking，main 线程在执行用户代码，需要更复杂的 write barrier 保证 marking 不出错
- 使用 remembered set 记录指针指向，保证移动后能快速更新引用
    - 有 `objA.X = objB`，则 remembered set 里增加一个 `objB -> objA.X` 这样的反向记录
    - `objB` 移动后，根据 remembered set 去更新 `objA.X` 的指针地址

---

### data

- 内存中如何表示数据，对 GC 也非常重要
- V8 把内存分成了各种不同 space
- space 里有 page，page 大小固定、对齐。page 里面才是用户申请的对象。
- 保守式 GC 会把所有像指针的视为指针，V8 用 bottom bit 区分 Smi 和指针

---

### 疑问

- 为什么 V8 把 young 分成了 nursery 和 intermediate？intermediate 对整体的 GC 性能能带来多少提升呢？
- TODO，如何 parallel copying
- TODO，如何 parallel marking
- TODO，如何 concurrent marking
- TOOD，remembered set 如何实现

---

参考资料
- https://v8.dev/blog/tags/memory
- http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection
- https://github.com/thlorenz/v8-perf/blob/master/gc.md

---

自己把几种算法实现了一下，一点经验

- 引用计数要注意计数和回收的时机（废话）。
    - 比如先减一再加一的场景，减一时计数归零怎么办？调换加减顺序？延迟操作？
    - demo 里一开始用了数组。遇到的问题是碎片怎么办？
- 复制和标记清除，都要注意移动带来的指针变化（也是废话）。
