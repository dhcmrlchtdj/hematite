# CMU-DB 15445 (2019 fall)

---

## Database Storage

- engine -> buffer pool (memory) -> storage manager (disk)
- database pages
    - directory file (map page_id to page)
    - slotted page: page header, slot array, tuples
    - tuple: tuple header, byte sequence
        - tuple_id = (page_id, offset)
- others
    - why not mmap
    - log-structured
    - how to represent data (int, float, string, datetime, blob)
    - OLAP vs OLTP, use case
    - row store vs column store, use case, advantages and disadvantages

---

## Buffer Pool

- buffer pool vs OS page cache
- buffer pool: page_table(map page_id to frame) + frame(page)
- evict policy
    - LRU
    - CLOCK
- dirty flag, write back to disk
- optimization
    - multiple pool, different pool for pages of different type (tuple, index, ...)
- lock vs latch
    - lock for high-level, for example, transaction
    - latch for low-level, for example, buffer pool page

---

http://www.interdb.jp/pg/pgsql08.html

PG 里使用了 clock sweep (a variant of Not Frequently Used) 来处理不再使用的缓存。
顺序读取很大的 table，可能导致大量 buffer 失效。
为了避免这种问题，PG 在部分场景不使用 buffer pool，而是一个独立的 ring buffer。

---

## B+ tree index

- operation (insert, delete)
- design decision
    - duplicate key
- optimization
- usage
    - implicit index
    - partial index

---

- radix tree
- inverted index, for full-text search

---

- 又讲了一次 lock vs latch
- 在 DBMS 里，lock 是指 transaction 的锁，latch 是指 data structure 的锁
- 数据库里似乎都是用读写锁

---

- btree + latch
- latch crabbing / coupling
    - 按 btree 的层次处理锁
        - 关键在于，哪些情况下，可以释放父节点的锁
        - 也就是，哪些情况下，子节点的修改，不会影响到父节点
    - 优化（乐观锁
        - insert/delete 的时候，总是要拿到写锁，影响性能
        - 先按 read 的方式拿读锁，只在 leaf node 拿写锁
        - 如果不安全，再重新全程写锁
    - 在 leaf node 处理 range scan 的时候，要小心死锁
        - range scan 是横向拿锁，而latch crabbing 是纵向拿锁，可能会出问题

---

## operator execution

---

### sort by

- in-memory sort
    - quick sort
- external sort
    - merge sort
    - double buffer optimization (在 IO 时利用好 CPU 资源

---

### group by, distinct

- hashing do more sequential IO

- if sort is not required, hash is a better choice
    - external hash

---

### join

- join 操作，就是找出两个列表的重复项。嵌套的两层循环、先排序再比较、计算 hash，数据库用了这三种算法。
- DBMS 特别的一点是，需要考虑硬盘 IO 的次数，以及可用内存的大小

- nested loop join
    - use the smaller table as the outer table
- sort-merge join
- hash join
    - 如果内存放不下整个 hash table，要怎么优化

---


