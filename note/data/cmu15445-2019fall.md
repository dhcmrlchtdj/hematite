# CMU-DB 15445 (2019 fall)

---

## Database Storage

- engine -> buffer pool (memory) -> storage manager (disk)
- database pages
    - directory file (map page_id to page)
    - slotted page: page header, slot array, tuples
    - tuple: tuple header, byte sequence
        - tuple_id = (page_id, offset)
- others
    - why not mmap
    - log-structured
    - how to represent data (int, float, string, datetime, blob)
    - OLAP vs OLTP, use case
    - row store vs column store, use case, advantages and disadvantages

---

## Buffer Pool

- buffer pool vs OS page cache
- buffer pool: page_table(map page_id to frame) + frame(page)
- evict policy
    - LRU
    - CLOCK
- dirty flag, write back to disk
- optimization
    - multiple pool, different pool for pages of different type (tuple, index, ...)
- lock vs latch
    - lock for high-level, for example, transaction
    - latch for low-level, for example, buffer pool page

---

http://www.interdb.jp/pg/pgsql08.html

PG 里使用了 clock sweep (a variant of Not Frequently Used) 来处理不再使用的缓存。
顺序读取很大的 table，可能导致大量 buffer 失效。
为了避免这种问题，PG 在部分场景不使用 buffer pool，而是一个独立的 ring buffer。

---

## B+ tree index

- operation (insert, delete)
- design decision
    - duplicate key
- optimization
- usage
    - implicit index
    - partial index

---

- radix tree
- inverted index, for full-text search

---

- 又讲了一次 lock vs latch
- 在 DBMS 里，lock 是指 transaction 的锁，latch 是指 data structure 的锁
- 数据库里似乎都是用读写锁

---

- btree + latch
- latch crabbing / coupling
    - 按 btree 的层次处理锁
        - 关键在于，哪些情况下，可以释放父节点的锁
        - 也就是，哪些情况下，子节点的修改，不会影响到父节点
    - 优化（乐观锁
        - insert/delete 的时候，总是要拿到写锁，影响性能
        - 先按 read 的方式拿读锁，只在 leaf node 拿写锁
        - 如果不安全，再重新全程写锁
    - 在 leaf node 处理 range scan 的时候，要小心死锁
        - range scan 是横向拿锁，而latch crabbing 是纵向拿锁，可能会出问题

---

## operator execution

### sort by

- in-memory sort
    - quick sort
- external sort
    - merge sort
    - double buffer optimization (在 IO 时利用好 CPU 资源

### group by, distinct

- hashing do more sequential IO

- if sort is not required, hash is a better choice
    - external hash

### join

- join 操作，就是找出两个列表的重复项。嵌套的两层循环、先排序再比较、计算 hash，数据库用了这三种算法。
- DBMS 特别的一点是，需要考虑硬盘 IO 的次数，以及可用内存的大小

- nested loop join
    - use the smaller table as the outer table
- sort-merge join
- hash join
    - 如果内存放不下整个 hash table，要怎么优化

---

## query

- processing model
    - iterator model / pipeline model / volcano model
        - the most common
        - `child.next()`, get a tuple from child operator
        - `emit(tuple)`, yield a tuple to parent operator
        - 一些有状态的操作，会等所有 tuple 返回。比如 join, subquery, order by 什么的，被称为 pipeline breakers
    - materialization model
        - ideal for OLTP, in-memory DBMS
        - `child.output()`, get all tuples from child operator
        - `return [tuple, ...]`, return all tuples to parent operator
        - 一次性把全部数据都放到内存里，适合一次操作少量数据的场景（也就是 OLTP 啦
            - 减少了反复调用 `next()` 的开销
    - vectorized model / batch model
        - like iterator model, but batch
        - ideal for OLAP
        - `child.next()`, get N tuples from child operator
        - `emit([tuple, ...])`, yield N tuples to parent operator
        - 一次获取多行数据，所以叫 batch。（也是为了减少 `next()` 调用的开销

- access method
    - sequential scan
        - optimization
            - zone maps
                - 提前计算好 page 的最大最小值等信息
                - 如果碰巧能参与 where 的条件判断，可以跳过不需要的 page
    - index scan
    - multi-index scan / bitmap scan
        - 一个 query 匹配了多个 index，对结果取交集（可以使用 bitmap/hash_table 等方式

- parallel execution
    - multi-process, multi-threaded
    - IO
        - replication (transparent to the DMBS
        - partition (transparent to the application, ideally
    - query
        - inter-query
            - multi-query in parallel
            - increase throughput, reduce latency
            - lock
        - intra-query
            - one-query, multi-operator in parallel
            - decrease latency for long-running query
            - approach
                - horizontal （数据分成多份，并行处理，然后聚合
                - vertical （不同 worker 处理不同 operator（感觉好像和普通方式没啥区别？
                    - pipelined parallelism
                    - used in stream processing systems
