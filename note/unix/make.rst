基础
=====
+ Managing Projects with GNU Make, Third Edition
+ http://www.gnu.org/software/make/manual/


**注意** ： ``makefile`` 里面用制表符（tab）来缩进。

.. code:: makefile

    # comment
    target1 target2 target3: prerequisite1 prerequisite2
        recipe1
        recipe2
        recipe3


+ ``#`` 是注释。
+ ``target`` 目标，可以看成函数名。
+ ``prerequisite`` 依赖，可以看成参数，必须是变量或者文件路径。也可以没有依赖。
+ ``recipe`` 具体指令，其实就是 shell 命令。也可以没有具体指令。
+ 没有依赖或指令的目标，叫做伪目标（phony target）。

.. code:: makefile

    .PHONY: all clean

    all: target1 target2 target3

    clean:
        rm target_file



内置变量
=========

内置变量和 shell 里面有点区别。

+----------+--------------------------------------+
| 内置变量 | 值                                   |
+==========+======================================+
| ``$@``   | 目标名                               |
+----------+--------------------------------------+
| ``$^``   | 全部依赖，空格分割，会去除重复项。   |
+----------+--------------------------------------+
| ``$+``   | 全部依赖，空格分割，不会去除重复项。 |
+----------+--------------------------------------+
| ``$?``   | 比目标新的依赖，空格分割。           |
+----------+--------------------------------------+
| ``$<``   | 第一个依赖。                         |
+----------+--------------------------------------+
| ``$%``   |                                      |
+----------+--------------------------------------+
| ``$*``   |                                      |
+----------+--------------------------------------+

内置变量可以加上 ``D`` 或 ``F`` ，用来获取目录或文件。
如 ``$(^D)`` ``$(<F)`` 。





查找路径
=========

.. code:: makefile

    vpath pattern directory-list

    vpath %.c src

``make`` 在查找依赖文件的时候，会把 ``vpath`` 指定的路径加入到查找路径中。
先找当前路径，找不到再找 ``vpath`` 指定的路径。
可以输出 ``$^`` ，查看找到的具体是哪个文件。




变量
=====
通常使用 ``$(name)`` 的方式来获取变量。
如果变量名只有一个字母，也可以把括号省略掉（比如内置变量就属于这种情况）。

``make`` 里的变量分为两种，
一般变量（simply expanded variable）和
递归变量（recursively expanded variable）。

一般变量使用 ``:=`` 来声明， **声明** 的时候，结果就固定了。
递归变量使用 ``=`` 来声明， **调用** 的时候，才计算结果。


此外，还有 ``?=`` 和 ``+=`` 。
``?=`` 只在变量没有声明的情况下，才对变量赋值，属于递归变量。
``+=`` 用于在变量后面追加一些值，一般变量还是一般变量，递归变量还是递归变量。

.. code:: makefile

    simple := simply_expanded
    recursive = recursively_expanded

    condition ?= variable

    append += variable



宏
===
用起来和变量一样

.. code:: makefile

    define macro_name
        recipe1
        recipe2
    endef

    target:
        $(macro_name)

缩进是我自己加的，有没有都没关系。

和递归变量类似，是在调用的时候才执行。





命令修饰符
===========

+ ``@`` ，关闭输出。
  ``make`` 默认会输出当前执行的命令。
+ ``-`` ，忽略错误。
  ``make`` 默认在发生错误时停止。
+ ``+`` ，强制执行。
  ``make -n`` 默认是不执行命令的。



命令
======

make 里每个指令都会新建一个 shell 环境，变量、路径不会互相影响。



执行 shell 命令
=================

``$()`` 被用于变量，所以不能在指令（recipe）中使用这种方式调用 shell 命令。
要执行 shell 命令的时候，可以使用 ``\`command\``` ，也可以使用 ``$(shell command)`` 。

