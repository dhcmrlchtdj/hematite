luagit gc
==========
+ http://wiki.luajit.org/New-Garbage-Collector

垃圾回收大致分为两个阶段：

1. 标记（mark）阶段，标记所有有效对象，没有标记的都是无效对象。
2. 清除（sweep）阶段，释放所有无效对象。


二色标记清除（two-color mark & sweep）
---------------------------------------
+ 新对象标记为白色。
+ 标记阶段，所有可用对象标记为黑色。
+ 清除阶段，先释放白色（不可用）对象，再将所有对象标记为白色。

+ 缺点是执行线程和回收线程不能交叉执行。
+ 原子型回收（atomic collection），非增量（non-incremental）。

+ 优化：每经过一次循环，交换黑白的含义，
  省去清除阶段把所有对象标记为白色的开销。

+ 实现：lua5.0 中，使用链表来保存对象。



三色增量标记清除（tri-color incremental mark & sweep）
-------------------------------------------------------
+ 新对象标记为白色。
+ 标记阶段，将可用对象标记为灰色。
  对于所有灰色对象，先标记其能接触到的对象，在转换为黑色。
+ 清除阶段，先释放白色（不可用）对象，再将所有对象标记为白色。

+ 属于增量（incremental）回收。
  回收线程可以处理部分对象后，让执行线程先执行，之后再继续处理剩下的对象。
  这点对于交互应用非常重要。
+ 交错执行也会带来问题：可能出现对象在标记阶段被标记为白色，
  然后被其他对象引用，然后这个对象在清除阶段被释放。
+ 一种解决方案是：不在黑色（可用）对象中引用白色（不可用）对象。
  在每次写入时，进行相应的检查。

优化方案：

+ 对象没有对其他对象的引用，直接从白色标记为黑色而不是灰色。




分代回收（generational gc）
----------------------------
+ 每代回收线程使用独立的内存空间。（典型的是三代。）
+ 新对象放在最新的回收线程中。
+ 用复制（copy）阶段代替清除阶段。
  可用对象复制到下一代回收线程里，剩下的不可用对象直接清除。
+ 在最后一代回收线程里，使用通常的标记清楚算法回收空间。

注：上面的线程不是指和进程对应的那个线程（thread），只是我自己给个称呼。

+ 最后一代回收线程称为主回收线程（major collection），
  其余称为次回收线程（minor collection）。
+ 次回收线程只关心新对象。
+ 主回收线程处理全部对象，但是运行频率要比次回收线程低。
+ 次回收线程在执行时。
  清除阶段，释放白色（不可用）对象，但是不改变对象的颜色。
  标记阶段，只遍历新对象和有写入的对象，其他对象都直接假设为可用的。





动态内存管理
=============
+ http://blogs.msdn.com/b/abhinaba/archive/2009/01/25/back-to-basic-series-on-dynamic-memory-management.aspx

引用计数（reference counting）
-------------------------------
记录每个对象的引用数，当引用数为零时，对象就不可用了，可以清除掉。

可以在每个对象前面多分配一点空间，用于记录引用数。

最大的问题是不能处理循环依赖的情况。
这点可以通过定期使用标记清除法来解决。

另外，在多线程环境下，更新引用计数的时候需要加锁，造成性能问题。
还有，对于占据空间很小对象，在前面分配用于引用计数的空间，
增加了对象的体积（有点划不来？）。

优点是实现简单，而且可以在引用数归零时，快速释放空间。
回收过程被分散在了程序执行的整个周期，对实时系统的影响不像标记清除法那么大。



标记清除（mark-sweep）
-----------------------
可以参考之前的笔记，简单总结一下就是：标记可用对象，清除不可用对象，去除标记。

这个标记一样可以放在对象开头。

标记的过程是个递归过程，在对象 *没有其他引用* 或者 *其他引用已经标记了*
的情况下才会停止。

执行垃圾回收的时机：

1. 系统空间开始吃紧的时候。
2. 内存过于分散的时候。
3. 分配了一定量的内存后。（.NET 里面是 1M。）


优点是能够处理循环引用的情况。
进行压缩（compaction）技术，可以减少内存碎片，加快后续分配的速度。

缺点是需要暂停程序，扫描全部内存。
这种开销对于实时应用来说是个大问题。
借助增量型的标记清除方法，可以缓解这个问题。


复制（copying）
----------------
把内存分为两块，活动内存和空闲内存。
在创建新对象时，将对象添加到活动内存的末尾。
等活动内存耗尽，开始把可用的对象移动到空闲内存。
之后活动内存转换为空闲内存，空闲内存转换为活动内存。

优点是创建对象的速度快。
缺点是为了进行切换，需要有两倍的内存。


分代（generational）
---------------------
算是标记清除法的改进。

几点经验（或者叫假设会不会更好些）：

1. 大部分对象在创建不久后，就不可用了。
2. 被回收的对象里，超过 90% 都是上次回收后新创建的。
3. 如果对象存活的时间超过一个回收周期，
   那么这个对象在短时间内变得不可用的概率就比较小。
   因此，在回收阶段进行检查和标记所造成开销，纯属浪费。

也就是 *越老的对象生存几率越大* 。

分代回收就是按照上述经验，将对象分类，按照不同的频率进行检查。

一开始，新对象都放在第一代，垃圾回收之后，将存活的对象移动到第二代。
后面也是同样的道理，垃圾回收后，将存活的对象移动到下一代。
进行垃圾回收的频率随代数降低。

（在 .NET 里，划分了三代。）
