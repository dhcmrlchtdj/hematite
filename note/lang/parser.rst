==========
 语法分析
==========

语法分析器的类型
=================

自底向上
    从叶节点开始，向根节点方向构造。

自顶向下
    从根节点开始，向叶节点方向构造。


手工实现的语法分析器通常使用 LL 文法。
处理 LR 文法的语法分析器通常是由自动化工具构造的。


自顶向下方法不能处理含有左递归的文法。

-------------------------------------------------------------------------------

上下文无关文法
===============

定义
-----

上下文无关文法由 ``终结符号`` ， ``非终结符号`` ，
``一个开始符号`` ， ``一组产生式`` 组成。

+ 终结符号：串的基本符号。
+ 非终结符号：串的语法变量。
+ 开始符号：一个非终结符号。
+ 产生式：将终结符号和非终结符号组成串的方法。
    产生式分为
    + 左部：非终结符号，产生式名。
    + 连接符号： ``->`` 或 ``::=`` 。
    + 右部：描述了左部的构造方法，又终结符号和非终结符号组成。


推导
-----

推导即将一个非终结符号替换为它的一个产生式。
每次推导要做两件事情：

+ 决定要替换哪个非终结符号。
+ 决定使用哪个产生式来替换。

最左/右推导：总是选择替换最左/右边的非终结符号。

最右推导又称为规范推导（canonical derivation）。


语法分析树
-----------

语法分析树是推导的树形表示。

推导与分析树之间存在多对一的关系
推导可以有不同的替换顺序，而分析树的表示则忽略了顺序。

对最左/右推导而言，其替换顺序是固定的，所以能与语法分析树一一关联。
即最左/右推导对应唯一的语法分析树。


二义性
-------

如果一个文法在处理某个句子时，可以生产不同的语法分析树，
那么这个文法存在二义性（ambiguous）。

-------------------------------------------------------------------------------

自顶向下语法分析
=================

自顶向下分析器为输入串构造语法分析树。
可以看作是对输入串进行最左推导的过程。
从根节点开始，先序（先根，深度优先）创建分析树的各个节点。

``LL(k)`` 向前看 k 个字符的预测分析器。


递归下降语法分析
-----------------

递归下降语法分析法中，为每个非终结符号建立一个分析过程。
整个程序从开始符号（一个非终结符号）开始执行整个分析，
扫描完整个输入串后，语法分析就完成了。

注：左递归的文法会使递归下降分析器进入无限循环。
所以不能使用递归下降分析法处理左递归的文法。


first 和 follow
----------------

``first(X)`` 表示文法符号串 ``X`` 的首符号（终结/非终结符号）的集合。

+ 若 ``X`` 是终结符号，则 ``first(X) = X`` 。
+ 若 ``X`` 是非终结符号，且 ``X -> ε`` 这个产生式存在，则 ``ε ∈ first(X)`` 。
+ 若 ``X`` 是非终结符号，且 ``X -> Y1Y2Y3...Yk`` ，则
    + ``first(Y1) ⊂ first(X)``
    + 若 ``ε ∈ first(Y1)`` ，则 ``first(Y2) ⊂ first(X)`` 。
    + 类推。

``follow(A)`` 表示紧跟非终结符号 ``A`` 的终结符号的集合。

+ ``$ ∈ follow(S)`` ，其中 ``$`` 表示字符串结束， ``S`` 表示开始符号。
+ 若 ``A -> xBy`` ，则 ``first(y) - ε ⊂ follow(B)`` 。
+ 若 ``A -> xB`` ， 则 ``follow(A) ⊂ follow(B)`` 。
+ 若 ``A -> xBy`` 且 ``ε ∈ first(y)`` ，则 ``follow(A) ⊂ follow(B)`` 。

-------------------------------------------------------------------------------

预测分析器
===========

为 ``LL(1)`` 文法构造的不需要回溯的递归下降语法分析器，称为预测分析器。

+ ``L`` 代表自左向右扫描输入。
+ ``L`` 表示使用最左推导。
+ ``1`` 表示每次只需向前看一个符号来确定语法分析动作。

LL(1)
------

文法 ``G`` 满足 ``LL(1)`` 当且仅当 ``G`` 中的任意两个产生式 ``A -> a|b`` 满足

+ 不存在终结符号 ``x`` 能同时使 ``a`` ， ``b`` 推导出 ``x`` 开头的串。
+ ``a`` ， ``b`` 最多只有一个能推导出空串。
+ 如果 ``a`` 经过任意次数的推导能推出 ``b`` ，那么 ``b`` 不能推导出任何
  以 ``follow(A)`` 中的非终结符号开头的串。

前两条即要求 ``first(a)`` 和 ``first(b)`` 不相交。
第三条即要求 在 ``ε ∈ first(a)`` 的情况下，
``first(b)`` 和 ``follow(A)`` 不相交。

存在左递归和二义性的文法都不满足 ``LL(1)`` 。


预测分析表
-----------

在构造预测分析表时，对文法 ``G`` 的每个产生式 ``A -> a``

+ 对 ``first(a)`` 中的每个终结符号 ``x`` ，令 ``M[A, x] = A->a`` 。
+ 如果 ``ε ∈ first(a)`` ，则对 ``follow(A)`` 中的任意终结符号 ``x`` ，
  令 ``M[A, x] = A->a`` 。
+ 如果 ``ε ∈ first(a)`` 且 ``$ ∈ first(a)`` ，令 ``M[A, $] = A->a`` 。


替换
-----

读取输入，从 ``开始符号`` 起进行替换。根据预测分析表中的匹配项，
选择相应的产生式右部进行替换，重复匹配替换，直到匹配到一个 ``终结符号`` 。
此时，算是正式处理了读取的输入，随即读取下个输入符号，继续匹配过程。
如果出现终结符号与输入符号不匹配的情况，说明发生了错误。

-------------------------------------------------------------------------------

自底向上语法分析
=================

自底向上语法分析的过程可以视为将输入串 ``w`` 归约为文法开始符号的过程。

归约（reduction）即将一个与产生式右部匹配的字串替换为产生式左部非终结符号。

同样是两个关键问题

+ 何时进行归约。
+ 用哪个产生式进行归约。

归约是最右推导的反向操作。
对输入进行从左到右扫描，进行自底向上语法分析，即可反向构造出一个最右推导。

句柄（handle）是和产生式右部匹配的子串。
但与产生式右部匹配的最左子串不一定是句柄。
对句柄的归约代表了相应最右推导的的一个反向步骤。

-------------------------------------------------------------------------------

移入归约分析法
===============

shift-reduce 是自底向上分析的一种方法。

在一个栈中保存已读取的文法符号，一个输入缓冲区中保存要进行语法分析的文法符号。

句柄在被识别之前，总是出现在栈顶。

将输入符号读取到栈中，直到栈中的文法符号可以进行归约，
这些文法符号（也就是产生式的右部）出栈，
归约为一个非终结符号（也就是产生式左部），
压入栈中，判断能否继续归约，不能就继续读取输入符号。
一直进行直到分析完成或者发生错误。

+ 移入归约冲突：无法判断进行移入还是归约。
+ 归约归约冲突：无法从多个可能的产生式中进行选择。

LR
---

二义性的文法不是 ``LR`` 的。

``LR(k)`` 中

+ ``L`` 指从左到右扫描。
+ ``R`` 指反向最右推导。
+ ``k`` 指向前看 k 个符号。

其中 k=0,1 时，具有实践意义。

``LR`` 文法分析器是表驱动的。

只要存在一个从左到右扫描的移入归约语法分析器，
能够在文法 ``G`` 的最右句型的句柄出现时，识别这个句柄
（换言之，能够构造出该文法的语法分析表）,
这个文法就是 ``LR`` 的。

``LR`` 语法分析器通过维护状态，表明所处的阶段，从而决定进行移入还是归约。

SLR
----

简单 ``LR`` 语法分析器。

状态代表了项（item）的集合，
一个文法的 ``LR(0)`` 项由该文法的产生式左部加上位于产生式右部的点组成。

规范 ``LR(0)`` 项集族（canonical LR(0) collection）为构建
确定性有穷自动机提供了基础。

``LR(0)`` 自动机的状态对应规范 ``LR(0)`` 项集族的一个项集。



