+ https://github.com/kriskowal/q/blob/master/design/README.js



从更抽象的角度来讲，promise 类似于计算的结果，
感觉就像是 CPS 中的 continuation。

从实现的角度，promise 是有 ``then`` 方法的对象。
这个可以去翻 http://promisesaplus.com/ ，
不过 promises/a+ 规范超出这篇文章了。

最粗略的实现，可以看 ``q0.js`` 。
deferred 有两个方法， ``then`` 注册回调函数， ``resolve`` 会调用这些函数。
如果 ``then`` 是在 ``resolve`` 之后调用的，会直接执行要注册的回调函数。

-------------------------------------------------------------------------------

在 promises/a+ 规定，
promise 只能从 ``pending`` 状态转换到 ``fulfilled`` 或 ``rejected`` ，
之后就不能继续转换状态了。

所以在 ``q1.js`` 的实现中， ``resolve`` 只能调用一次。
从结果来讲，也就是注册的回调函数只会被调用一次。

为什么这么设计呢？

文中是这么解释的：
按照正常的流程，先是调用函数，然后函数返回结果或者抛出错误。
函数不会返回多次，也不会出现先返回一个结果，再抛出一个错误之类的情况。
既然 promise 是函数结果的抽象，那么 promise 也应该满足这种特点。
promise 从 ``pending`` 出发，发生状态转移，
对应于函数返回（ ``fulfilled`` ）或抛出错误（ ``rejected`` ）。
状态转移之后，相当于函数执行完了，既然函数不会返回多次，
promise 的状态也就不应该再改变了。

-------------------------------------------------------------------------------

``q2.js`` 和 ``q3.js`` 演示了如何将 promise 和 ``resolve`` 分离开来。
``q2.js`` 使用继承，靠 ``instanceof`` 判断；
``q3.js`` 检查 ``then`` 方法，也就是所谓的鸭子类型（duck-typing）。

那么，为什么要分离呢？主要是为了权限控制。

``resolve`` 只能决定解析状态， promise 只能获取解析状态。
将两种权限分离开来。（分开到底有什么好处？）

后面的实现里使用 ``q3.js`` 的方法，主要是为了兼容 promises/a+ 的不同实现。

-------------------------------------------------------------------------------

promises/a+ 规定，promise.then 必须返回一个 promise。

实现这一特性后，我们就能够将 promise 组合起来。

``q4.js`` 里，为了实现这个特性，代码一下子变乱了。

-------------------------------------------------------------------------------

前面都是在处理函数正常返回的情况，我们还要处理函数抛出错误的情况。

``q5.js`` 和 ``q6.js`` 添加了对 ``rejected`` 的支持。

其实也没有什么特别的地方，就是是实现了一个 ``reject`` 方法，
该方法返回的 promise 在调用 ``then`` 时，
会执行 ``errback`` 而不是 ``callback`` 。

-------------------------------------------------------------------------------

``q7.js`` 的着眼点是执行顺序，
保证回调函数的执行顺序和注册顺序相同。

就具体实现来说，也很简单。
不直接执行回调函数，而是将回调函数依次加入执行队列。
这就保证了回调函数执行的顺序是严格按照注册顺序进行的。

-------------------------------------------------------------------------------

promises/D 里规定了个 ``promiseSend`` 方法。
由于连 ``thenables`` 都还没完全明白，这个 ``promiseSend`` 就先略过了……

-------------------------------------------------------------------------------

最后的最后，回头看一下前面说的那个，一下子变得复杂起来的 ``q4.js`` 。

其实其他都好说，一下子看得有点郁闷的是 ``ref`` 的实现。
开始是直接调用回调函数，到这里变成了调用 ``ref`` 后的 ``then`` 方法。

借助 ``ref`` ， ``resolve`` 的参数被转换成了一个 ``thenable`` 对象，
也就是一个 promise 啦。

这个 promise 保留了传给 ``resolve`` 的参数，在调用 ``promise.then`` 的时候，
将这个参数传递给了 ``then`` 接受的回调函数。
（ ``then`` 的回调函数接受的参数，就是从这里，由 ``resolve`` 传递过去的。）

在这个 ``then`` 里面，对回调函数进行了调用，将结果再次包装成一个 promise。
（前面提过， ``q7.js`` 里面不再直接调用，而是放到一个调用队列里去了。
此外，这里返回的 promise 是被直接抛弃的，需要的只是调用了回调函数这个结果。）

再看一下 ``defer`` 里面的 ``promise.then`` ，每次也都是返回一个 promise。
这里这个 promise 要一直等到 ``defer`` 被 ``resolve`` 的时候，
才会调用相应的回调函数，进行 ``resolve`` 。
如果有后续的 ``then`` ，也是在这个时候被调用的。

有点虎头蛇尾的感觉，不过大体上就是这个样子了，接下去去研究下具体实现……
