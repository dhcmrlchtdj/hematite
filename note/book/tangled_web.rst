.. contents::




解析 url 的算法
================

一个链接大概就长这样：
``scheme://login.password@address:port/path/to/resource?query_string#fragment``

解析链接的算法：

1. 查找 ``:`` ，获取 ``scheme`` 。

    没找到的话，可能是有链接问题，也可能这个链接是个相对路径。

2. 查找 ``//`` 。

    找到了，直接丢掉。
    没找到，链接有问题。

3. 查找 ``/`` ``?`` ``#`` ，提取地址。

    1. 查找 ``@`` ，获取用户名和密码。
    2. 查找 ``:`` ，获取端口。

4. 提取路径。

    如果之前找到了 ``/`` ，那么查找 ``?`` 或 ``#`` 或 ``EOS`` ，
    中间的就是路径。

5. 提取查询字符串。

    如果之前找到了 ``?`` ，那么查找 ``#`` 或 ``EOS`` ，
    中间的就是查询字符串。

6. 提取片段标识符。

    如果之前找到了 ``#`` ，那么查找 ``EOS`` ，
    中间的就是片段标识符。

上面这个是解析链接的大体流程。
实际上，有些浏览器会接受一些特殊字符，链接本身也还有其他字符限制。
要写出更完全的解析程序，要多查些资料。




链接的字符限制
=================

::

    : / ? # [ ] @
    ! $ & ' ( ) * + , ; =

上面这些符号都是有特殊含义的。

确实需要使用这些符号的时候，可以进行 url 转义，也就是 ``%HH`` 。





cheat sheet 之 链接与用户输入
================================

+ 在构造链接时

    如果用户输入的数据，会出现在在路径、查询字符串或者片段标识符中，
    肯定要进行一些过滤。特别要注意那些用于分割链接的符号。

    最简单的方法是将数字和字母以外的符号全部转义掉。

+ 在接收链接时

    + 过滤相对路径。
    + 使用白名单过滤协议。
    + 域名只能由 ``[-.a-z0-9]`` 组成。

+ 在对参数进行解码时

    不管什么标准规定还是浏览器具体实现都不靠谱。
    自己处理好特殊符号。





HTTP 头部的分割符号
=======================

有些头部的值，使用 ``;`` 分割。
有些值，可以使用双引号包裹。

::

    Content-Disposition: attachment; filename="evil_file.exe;.txt"[CR][LF]

在某些版本的 ie 里，像上面这样的头部就有问题。
``;`` 会把 ``evil_file.exe;.txt`` 截断。


另外，一个头部重复出现的情况要怎么处理，RFC 没有规定。
这个取决与浏览器的实现。






cheat sheet 之 HTTP 协议
=========================

+ 如果要把用户输入放在 cookie 中

    对输入进行一次编码，最少要使用 url 转义（%HH）
    对数字字母之外的符号进行编码。
    用上 base64 的话就更棒了。

+ 如果重定向的地址和用户输入有关

    链接使用白名单进行过滤，这点之前提过了。

    记住转义转义转义。不能保证没问题的符号，都过滤了吧。
    比如 ``;`` 。

+ 如果用户可以决定文件名（存储在 ``Content-Disposition`` 中）

    + 如果只含有拉丁字符

        将 ``[.-_0-9a-z]`` 之外的符号都干掉。
        像 ``'";\[0x00-0x1F]`` 之类的符号，都有危险。

    + 如果要使用拉丁字符外的字符

        过滤 ``'";\[0x00-0x1F]`` 。
        对其他符号进行 url 转义，还有 RFC 2047，RFC 2231。

+ 其他 http 头部与用户输入

    注意亮点，一个这个头部的语法，一个是这个头部的作用。

    转义转义转义，过滤过滤过滤。包括但不限于 ``'";\[0x00-0x1F]`` 。






cheat sheet 之 HTML
========================

+ 正确的 ``Content-Type`` 和 ``charset`` 。

+ 过滤 html

    + 标签内的文本

        过滤掉 ``<>&`` 。

    + 标签的 style 和 on* 属性

        必须要多重转义，注意上下文。

    + 标签的普通属性

        使用引号把值包裹起来。过滤掉 ``<>&'"`` 。

        对于链接，要额外处理下。

    + 特殊的标签

        比如 ``script`` 和 ``style`` 。

        没什么可说的，转义转义转义。









cheat sheet 之 CSS
=====================

+ 不要设置标签的 ``style`` 属性。与其麻烦地过滤，干脆不要做这么危险的事情。

+ 使用白名单。


顺便提一下 css 的转义。css 使用的是 ``\XX`` 的方式进行转义的。
在转义后，接一个空格，表示结束。

::

    e
    \65     ==> e
    \065    ==> e
    \000065 ==> e
    t\65 ak ==> teak







js 转义
==========

+ "\n" 之类的操作符

    ES 和 JSON 标准都有定义。

+ "\145" (e)，三个 8 进制符

    ES 和 JSON 标准都没定义，只是大部分实现支持。

+ "\x65" (e)，两个 16 进制符

    ES 和 JSON 标准都没定义，只是大部分实现支持。

+ "\u0065" (e)，四个 16 进制符

    ES 和 JSON 标准都有定义。

+ ``\`` 和除 ``[0-7btvfrnxu]`` 以外的字符，

    .. code:: javascript

        "\a" === "a"; // true
        "\b" === "b"; // false

        "\1" === "1"; // false
        "\8" === "8"; // true

        "\"" === '"'; // true

    简单讲，就是上面 ``\`` 跟上面那些符号有特殊含义，所以不能直接转义。
