1.1.5
======
函数在求值的时候，有两种策略。

+ 应用序求值（applicative-order evaluation）

    先对参数进行求值，再执行函数。

+ 正则序求值（normal-order evaluation）

    先将函数展开，再进行归约（reduce）。


书里给了个例子来测试程序使用哪种方式求值：

.. code:: scheme

    (define (p) (p))
    (define (test x y) (if (= x 0) 0 y))
    (test 0 p)



3.2
====
*函数式编程* 中的函数调用（或者叫做将过程（procedure）应用（apply）于参数），
可是看作是使用 *实际参数* 替换函数中的 *形式参数* 后，对函数求值的过程。

*指令式编程* 中的函数调用，会创造一个新的框架（作用域），
并在这个框架中对函数进行求值（也就是对函数中的变量进行约束啦）。

简单讲就是，前者是 *代换模型* ，后者是 *环境模型* 。





3.4
====
在引入赋值之前，程序没有时间问题。求值结果不会改变。

而赋值语句执行时，会改变求值环境。
求值结果不仅依赖于表达式本身，还要考虑求值是发生在赋值之前还是之后。
（也就是说，我们必须在计算模型中，考虑时间因素。）


3.4.1
------
可以在不同程度上，对并发进行限制，比如：

+ 如果两个操作都要修改某个共享变量，那么这两个操作必须顺序执行。

或是宽松一点的：

+ 保证并发进程产生的结果和各个进程顺序运行的结果相同。


3.4.2
------
处理并发程序的难点在于，如何处理不同进程中，事件相互交错的情况。
