# grand central dispatch

---

https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html
https://apple.github.io/swift-corelibs-libdispatch/tutorial/

---

> The obvious way to take advantage of multiple cores is to write programs that
> do several tasks at once.

> leaving behind the details about threads and
> focusing on the essential work that needs to be done

> which items must be done sequentially,
> which may be done in parallel,
> and what synchronization is required between them

---

## Queues

---

> A queue is a pipeline for executing blocks and functions.

> Serial queue execute work units in First-In-First-Out (FIFO) order, and
> execute them one at a time.

> Concurrent queues also execute work units in FIFO order, but they don’t wait
> for one unit to finish executing before starting the next.

---

```c
main() {
    dispatch_queue_t main_q = dispatch_get_main_queue();
    dispatch_async(main_q, ^{ printf("Hello X!\n"); });
    dispatch_async(main_q, ^{ printf("Hello Y!\n"); });
    dispatch_async(main_q, ^{ printf("Hello Z!\n"); });
    dispatch_async(main_q, ^{
        printf("Goodbye!\n");
        exit(0);
    });
dispatch_main();
}
```

```c
main() {
    dispatch_queue_t greeter = dispatch_queue_create("Greeter", NULL);
    dispatch_async(greeter, ^{ printf("Hello X!\n"); });
    dispatch_async(greeter, ^{ printf("Hello Y!\n"); });
    dispatch_async(greeter, ^{ printf("Hello Z!\n"); });
    dispatch_sync(greeter, ^{ printf("Goodbye!\n"); });
    return 0;
}
```

> it’s good to be a little bit cautious when using `dispatch_sync`.
> More than one programmer has inadvertently created a deadlock in their program
> logic caused by making a synchronous call in the wrong place!

---

## Serial Queues

---

> A serial queue can also be used as a device that provides mutual exclusion.
> After all, it only executes one item at a time.

---

## Semaphores

---

`dispatch_semaphore_create`

---

## Sources

---

> react to events generated by users, network sources, timers, ...

---

## Groups and callbacks

---

> a group keeps track of a set of work items.
> can either wait for them all to complete, or set up the group to submit a
> block or function to a queue when they all complete.
