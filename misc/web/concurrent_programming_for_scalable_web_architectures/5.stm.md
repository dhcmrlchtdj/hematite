# software transactional memory

---

http://berb.github.io/diploma-thesis/community/053_stm.html

---

STM 和多线程一样使用 shared state 和 lock。
但是 STM 不需要手动控制锁，提供了高一级的抽象。

---

## transactional memory

+ 可以类比数据库的事务，数据库是读写数据库里的每一行数据，
    TM 是读写共享数据。
+ 除了后面要讲的 STM，还有 hardware TM / hybrid TM
+ 事务的并行控制分为 pessimistic 和 optimistic
+ pessimistic 会对资源加锁，所以吞吐量不高
+ optimistic 在事务结束时才进行完整性的检查。
    发生冲突时，当前事务终止并重新执行
+ 如果冲突不是很多的化，optimistic 的策略能带来很好的整体性能

---

## software transactional memory

+ 目前 optimistic 的实现更加常见
+ 事务开始的时候，程序记录当前状态。
    事务进行的时候，所有的修改都是在事务内进行的。
    事务结束的时候，会检查是否出现冲突，没冲突就把事务中的修改提交。
    出现冲突时，事务重新开始。
+ 整个过程都是底层实现的，代码本身不需要关心
+ 如果一个事务运行时间很长，就很可能因为其他事务先完成导致最后出现冲突

+ 组合和协作方面，事务提供了一些操作，能在某些条件触发时继续执行

+ STM 也存在一些限制，比如只支持内存操作
+ 事务中不能出现副作用，否则冲突重试会造成预料外的结果

+ STM 能保证并行操作不产生死锁
+ 多个事务同时修改一个值时，还是会出现 contention
+ 一个较长的事务与一些较短的事务一起时，还是会造成 starvation

---

## TM / GC

一些对 STM 的质疑

+ 事务和非事务同时修改某个值，应该如何处理
+ 如何记录私有状态
+ 事务里不能有副作用，要怎么和其他操作整合在一起
+ 处理事务带来的性能损失

和 GC 放在一起看一下

+ GC 是管理内存中的引用，STM 管理内存中的状态
+ 都是运行时的一些操作，都是为了减轻手动维护的困难
+ 受到类似的质疑（笑

---

## application logic

+ 和线程模型一样，每个请求对应一个线程。
+ 之前提过线程模型不适合 IO 密集型的请求，STM 干脆禁止在 transaction 中进行 IO 操作
+ STM 不需要手动控制锁，使得共享数据变得更简单可控，但是没能解决并行 IO 的问题
