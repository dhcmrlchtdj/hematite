.. contents::


排序
=======

排序的时间复杂度
-------------------

用选择排序为例，我们要做的是每次找出最小的元素，就这么遍历整个数组。

如果使用普通的数组来实现，每次查找最小元素的时间复杂度为 `O(N)` ，
遍历 `N` 个元素，所以整个排序的时间复杂度为 `O(N*N)` 。

如果使用优先队列来实现，那么查找的时间复杂度为 `O(logN)` ，
遍历 `N` 个元素，最后的时间复杂度为 `O(N*logN)` 。

总之，应该针对不同问题，选择合适的数据结构。



插入排序
-------------

插入排序，任意选取元素，然后放到合适的位置。
寻找合适位置的开销为 `O(N)` ，所以遍历元素到最后，开销为 `O(N*N)` 。



选择排序
------------

选择排序，选取最小的元素，接到末尾。
选取最小元素的开销为 `O(N)` ，遍历，最后时间复杂度为 `O(N*N)` 。



堆排
-----------

堆排，逻辑上属于选择排序，每次找出最小的元素。
只是使用的数据结构比较巧妙，使得寻找最小元素的时间复杂度降为 `O(logN)` ，
所以最后的时间复杂度为 `O(N*logN)` 。



归并排序
--------------

分治算法。
把大问题分解成小问题，最后将小问题的结果归并，获得大问题的结果。

归并排序适合用于链表，排序时不需要额外的空间，只要改变指针指向。
此外，归并排序不像堆排，不需要对元素进行随机读取。



快排
----------

随机算法。用于划分的基准是随机选取的。

快排是不稳定的。

依照实践经验，快排比归并排序和堆排要快上两三倍。
当然，前提是这个实现要足够好（快排内部的循环会更简单些）。
