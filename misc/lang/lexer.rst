=======
 lexer
=======

词法分析 lexical analysis
==========================

``词法分析`` 把 ``字符流`` 转化为 ``符号流`` 。

``词法分析器`` 逐个扫描字符，根据模式，获取整个词素，
按符号标记分类，将结果存储在符号表中。

通常使用正则表达式来表示一个模式，获取词素的过程就成了模式匹配的过程。
根据匹配结果，可以确定词素的值和类型。

名词解释 glossary
------------------

+ 词法分析器 lexical analyzer / lexer / scanner
    进行词法分析的程序或者代码

+ 词素 lexeme
    字符流中的完整单元

+ 符号 token
    词素的类型，每个词素都属于某个符号。

+ 模式 pattern
    符号就是所有词素依照模式进行划分得到的等价类。

+ 符号表 symbol table
    保存了出现的所有符号，包括符号类型和值。

-------------------------------------------------------------------------------

正则表达式 regular expression
==============================

通过构造有穷自动机，可以把正则表达式编译成识别器，用于识别词素。

通常先将正则表达式转换为 NFA，再将 NFA 转换为 DFA。
因为正则到 NFA 较为直接，而 DFA 的匹配速度较快。
三者在匹配能力上是等价的。


名词解释 glossary
------------------

+ 状态机（state machine）
    能在多个状态之间进行转换的一种结构。
    满足一定条件时，可以从一个状态转换到另一个状态。

+ 有穷自动机（finite-state automaton）/ 有穷状态机（finite-state machine）
    状态的总个数是有限的。

+ 确定性有穷自动机（DFA, deterministic finite automaton）
    一个条件，只有一个后继状态。

+ 非确定性有穷自动机（NFA, nondeterministic finite automaton）
    一个条件，可能有多个后继状态。

-------------------------------------------------------------------------------

非确定性有穷自动机 NFA
=======================

NFA 包括：
+ 状态集合。
+ 输入符号集合，包括一个特殊符号，ε（epsilon），表示空。
+ 转移函数，从（状态，符号）到（状态）的映射，
    一个（状态，符号）二元组可能映射到多个状态。
+ 初始状态（唯一）。
+ 终止状态（不唯一）。

NFA 可以表示为一个有向图，称为转换图（transition graph）。
节点为状态，边为符号。（节点，边）到指向的（节点），就是转移函数。

-------------------------------------------------------------------------------

确定性有穷自动机 DFA
=====================

DFA 是 NFA 的特例，区别在于：
+ 输入符号不能为 ε。
+ 转移函数是只能映射到一个状态。

DFA 在任意状态下，对一个输入符号，最多存在一种转换。

-------------------------------------------------------------------------------

子集构造法 subset construction algorithm
=========================================

使用子集构造法，能够将 NFA 转换为等价的 DFA。

DFA 中的每个状态 都对应 NFA 中某些状态的集合。

NFA 状态上的操作：
+ 集合`ε-closure(s)`表示从状态 s 出发，经过 ε 边，可以到达的所有状态。
+ 集合`ε-closure(T)`表示从状态集合 T 中的所有状态出发，
    经过 ε 边，可以到达的所有状态。
+ 集合`move(T, a)`表示从状态集合 T 中的所有状态出发，
    经过 a 边，可以到达的所有状态。


转换
-----

1. 从 s0 出发，经过 ε 边，到达集合 T0 = ε-closure(s0)。
2. 从 T0 出发，经过 a 边，到达集合 _T = move(T0, a)；
    从 _T 出发，经过 ε 边，
    到达集合 T1 = ε-closure(_T) = ε-closure(move(T0, a))。
3. 从 T1 出发，……

这样得到的所有状态集合 T0，T1，…… 就是 DFA 的所有状态。


实现
-----

+ 计算 epsilon(s0)，加入队列。
+ 遍历直到队列为空。队列中的元素都是 NFA 的状态集合。
+ 对每个元素，作为 DFA 的一个状态，做上标记，避免重复计算。
+ 对每个元素，遍历输入符号，计算 move(epsilon(s), a)，加入队列。
+ 得到的标记集合，即为 DFA 的所有状态。

细节：使用 bitset 记录 nfa 的标号，作为 dfa 的标记，避免多次遍历。

-------------------------------------------------------------------------------

thompson 构造法  thompson construction algorithm
=================================================

使用 thompson 构造法，将正则表达式转换为等价的 NFA。

通过如下规则，就可以将简单的正则表达式表示成一个 NFA。

.. code::

    epsilon => S->F
    a => S -a-> F
    ab => Sa -a-> Fa -> Sb -b-> Fb => S -a-> S1 -b-> F
    a|b => Sa -a-> Fa, Sb -b-> Fb, S->Sa, S->Sb, Fa->F, Fb->F
    a* => Sa -a-> Fa, Fa->Sa, S->Sa, Fa->F, S->F => S -a-> F, S->F, F->S
    a? => S -a-> F, S->F
    a+ => aa* => S -a-> S1, S1 -a-> F, S1->F, F->S1

-------------------------------------------------------------------------------

regex2dfa
==========

-------------------------------------------------------------------------------

补充
=====

+ 称一个含非 epsilon 出边的状态为`重要状态`。
+ 如果两个集合有相同的重要状态，可以认为这两个集合是等价的。

最小化 DFA 状态数
------------------

得到一个状态数最少的等价 DFA。

将所有状态放在一个集合中，进行划分。
可先分为接受状态集合和非接受状态集合。
对每个集合，遍历输入符号，如果对于一个符号，输出不同，则根据输出划分集合。
对划分出的集合进行相同处理，直到每个集合都不可分。
最终，相同的状态会分在相同的集合中，新的集合就对应新的状态。

所谓相同状态，即这些状态包含的 ``重要状态`` 相同，且 ``接受状态`` 相同。

-------------------------------------------------------------------------------

kmp 算法 与 trie 算法
======================

学习词法分析，可以帮助对 kmp 和 trie 的理解。

kmp
----

对于要匹配的字符串，其实就是一个正则表达式，
且这个正则没有任何特别的边，可以轻易地看作一个状态机。

对于输入，匹配就转入下一个状态，不匹配就转入前缀对应的状态。

如何寻找前缀对应的状态呢？
先后退到上一个状态，然后跑到上个状态对应的前缀状态，同步向前看。
出边的字符相同，则向前一步，这个即为对应的前缀状态；
出边的字符不同，则继续往回找上个前缀状态，重复上述过程。
直到回到初始状态，这说明没有对应的前缀。

trie
-----

trie 和 kmp 的原理是一样的，区别在于查看出边字符的时候，trie 可能有多个出边，
而 kmp 只有一个，所以只要在比较出边字符的时候多比较几个，就可以了。
