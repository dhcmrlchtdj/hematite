阅读材料
=========

+ ``man 1 bash``
+ http://mywiki.wooledge.org/BashGuide
+ http://wiki.bash-hackers.org/start




折行
=====
使用 ``\`` 来折行。

.. code::

    $ ls \
    > -a




变量作用域
===========
默认是全局变量，也可以声明为局部变量。

.. code:: bash

    global1=1 # 全局变量

    func() {
        global2=2 # 全局变量
        local local1=1 # 局部变量
        declare local2=2 # 局部变量
    }




修改环境变量
=============

.. code::

    $ cat example.sh
    #!/usr/bin/env bash
    var=10
    export var

    $ chmod u+x example.sh
    $ ./example.sh
    $ echo $var
    (nil)

    $ . ./example.sh
    $ echo $var
    10

    $ source example.sh
    $ echo $var
    10

直接执行脚本，会把变量导出到一个新的 shell 中。
要修改当前的环境变量，要使用 ``source`` 或者 ``.`` ，
都是 shell 的内置命令，用来在当前的 shell 之执行脚本的内容。





参数
=====

+----------------+----------------------------------------------+
| 参数           | 描述                                         |
+================+==============================================+
| $0             | 执行的脚本的名称，在哪都是脚本名             |
+----------------+----------------------------------------------+
| $FUNCNAME      | 执行的函数的名称，在函数外是空值             |
+----------------+----------------------------------------------+
| $1, ${10}, ... | 脚本或者函数的参数，在函数中和函数外是不同的 |
+----------------+----------------------------------------------+
| $#             | 参数的个数                                   |
+----------------+----------------------------------------------+
| $*, $@         | 参数列表，照数组理解就好                     |
+----------------+----------------------------------------------+

**注意** 上面提到的参数都是不包含 ``$0`` 和 ``$FUNCNAME`` 的，
这两个都是特殊的。

``$*`` 和 ``$@`` 只在使用引号的时候才有区别。
``$*`` 是一个字符串，其中的 ``c`` 是 ``IFS`` 的第一个字符。
而 ``$@`` 是每个参数对应的字符串。

+------+----------------------+
| $*   | $1 $2 ... ${N}       |
+------+----------------------+
| $@   | $1 $2 ... ${N}       |
+------+----------------------+
| "$*" | "$1c$2c...c${N}"     |
+------+----------------------+
| "$@" | "$1" "$2" ... "${N}" |
+------+----------------------+

另外， ``shift`` 命令可以用来移动参数。





数组
=====

.. code:: bash

    a=(10 9 8) # 初始化，可以为空
    a+=(7 6) # 加上另一个数组
    a[10]=1 # 中间都是空值填充，但是获取数组长度又是得到真实的长度

    ${a[0]} # 获取数组第一个元素
    ${a} # 也是获取第一个元素

    # 这个和前面的参数列表一样的情况
    ${a[@]} # 获取整个数组
    "${a[@]}"
    ${a[*]}
    "${a[*]}"

    ${#a[@]} # 获取数组的长度
    ${#a[*]}

    ${#a[0]} # 获取第一个元素的长度
    ${#a} # 获取第一个元素的长度

    ${!a[@]} # 获取数组元素的下标
    "${!a[*]}" # 加上引号和上面的情况一样，会变成一个字符串
    # 在这里拿来遍历数组就会出问题

    ${a[@]:0:2} # (10, 9) 从 0 开始，取出 2 个元素
    # 引号 还有 `* @` 的问题不再重复了

    unset -v a[2] # 删除数组元素，不改变下标
    unset -v a # 删除数组，这个时候就不是第一个元素了
    unset -v a[@]
    unset -v a[*]


bash 除了通常的数组，还支持关联数组，只有下标使用字符串，还有声明的方式两个区别。

.. code:: bash

    declare -a ia # 声明一个普通数组
    declare -A aa # 声明一个关联数组







字符串修改
==========

.. code:: bash

    s="String"

    # 大小写
    echo ${s^}  # String 首字母大写
    echo ${s^^} # STRING 大写
    echo ${s,}  # string 首字母小写
    echo ${s,,} # string 小写
    echo ${s~}  # string 首字母反转
    echo ${s~~} # sTRING 反转

    # 长度
    echo ${#s} # 6

    # 截取
    # ${parameter:offset:length}
    echo ${s:1:3} # tri

    # 替换
    # ${parameter/pattern/string} 替换首个
    # ${parameter//pattern/string} 替换全部
    echo ${s/S/s} # string
    echo ${s/S} # tring # "/string" 省略了，默认用空串替代

    # 删去符合模式的字符
    # {parameter#pattern} # 从头开始，最短
    # {parameter##pattern} # 从头开始，最长
    # {parameter%pattern} # 从尾开始，最短
    # {parameter%%pattern} # 从尾开始，最长
    ss="an example string"
    echo "${ss#*a}"     # 'n example string'
    echo "${ss##*a}"    # 'mple string'
    echo "${ss% *}"     # 'an example'
    echo "${ss%% *}"    # 'an'

除了进行修改，还可以根据字符串是否为空，进行处理

.. code:: bash

    s="" # 字符串为空/也可以是未声明的字符串

    # 如果为空，则使用 `-` 后的字符串
    echo "'${s:-blah}'"     # 'blah'
    echo "'${s}'"           # ''

    # 如果为空，则使用 `=` 后的字符串进行赋值
    echo "'${s:=blah}'"     # 'blah'
    echo "'${s}'"           # 'blah'

    # 如果不为空，则使用 `+` 后的字符串
    echo "'${s:+blahblah}'" # 'blahblah'
    echo "'${s}'"           # 'blah'






新执行环境
===========
使用 ``(...)`` 是在一个新的 `shell` 里面执行括号中的命令。





测试
====
``[`` 是函数， ``[[`` 是关键字。




数值计算
=========
使用 ``((...))`` 可以进行数值计算，括号内变量无需 ``$`` ，可以直接引用。







获取返回值
===========
如果只是要返回值，可以使用 ``$?`` 。

.. code:: bash

    ls
    echo "$?"

如果是要获取标准输出，可以使用 ``$(...)`` 。

.. code:: bash

    output=$(ls)
    echo "$output"

    # 这里只是随便举了个例子，要得到文件列表，直接用通配符就好，不要使用 $(ls)

这个只是获取标准输出，如果需要标准错误之类的，可以自己进行重定向。

.. code:: bash

    # 获取标准输出和标准错误
    output=$(command 2>&1)
    # 获取标准错误
    output=$(command 2>&1 >/dev/null)
    # 获取标准错误，打印标准输出到终端
    output=$(command 2>&1 >/dev/tty)
