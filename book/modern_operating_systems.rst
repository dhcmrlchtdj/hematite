.. contents::



2.1.5 进程状态
===============

运行态
    可以运行。在实际占用 CPU。

就绪态
    可以运行。在等待执行，此时 CPU 正在执行其他程序。

阻塞态
    无法运行。等待某种外部事件发生。





2.1.6
=======
系统维护着一张进程表（process table）。
表中的每个项都代表一个进程，保存着与进程相关的信息。


2.2.1
========

使用多线程的理由：

一，并行的实体间共享一个地址空间和所有可用数据的能力。
二，相比进程，线程在创建和撤销时的开销要小一些。
三，如果同时存在大量计算和大量 IO 处理，可以利用多线程来重叠执行。
四，多 CPU 系统中，可以进行真正的并行执行。

注意下，以上四点都是针对某种具体需求来说的。
如果不需要共享数据，那么一不成立；如果不需要频繁创建撤销，那么二不成立；
如果线程都是 CPU 密集型的，那么三不成立；
程序要针对多核进行优化，才会真正利用到多个 CPU。



2.2.4 用户级线程
=================

在用户空间实现线程。内核不知道线程的存在。

优点：

+ 可以在不支持线程的操作系统上实现。
+ 切换线程的速度快。相比进入内核空间，至少要快上一个数量级。
+ 可以针对不同程序使用不同的线程调度算法。

缺点：

+ 要实现阻塞的系统调用，比较麻烦。
+ 只要一个线程发生页面故障，就会影响整个进程。
+ 实际上只有一个线程在执行，且在线程交出控制权之前，无法中断。



2.2.5 内核级线程
=================

在内核中实现线程。

由于在内核中创建撤销线程的开销较大，一些系统在回收线程时，
只是把线程标记为不可用，并没有清除。
在需要创建新线程时，直接重用这些不可用的线程。
（用户级线程的创建开销较小，没必要使用这样的方式进行优化。）

基本上能解决用户级线程的所有问题，就是各种开销比较大。
另外，内核级线程也面临信号处理、创建子进程等问题。



2.2.6 混合线程
================

用户级线程和内核级线程的复用。两者的比例由编程人员决定。




2.4.2 批处理系统中的调度
=========================

+ 先来先服务 first-come first-serverd

    非抢占式。

+ 最短作业优先 shortest job first

    非抢占式。

    先执行所需时间最短的任务。适用于运行时间可以预知的情况。
    只有在所有作业都处在可执行状态下，这个调度算法才是最优化的。

+ 最短剩余时间优先 shortest remaining time next

    最短作业优先的抢占式版本。

    区别在于添加新任务时，可能会选择打断当前任务，执行新任务。



2.4.3 交互系统中的调度
=======================

+ 轮转调度 round robin

    给每个进程分配一个时间片（quantum），一旦超过时间，就将进程挂起。

    时间片分得太短，会导致频繁切换进程，降低 CPU 效率。
    时间片分得太长，会增加响应请求所需的时间。
    一般来说， 20-50 ms 是个合适的值。


+ 优先级调度

    给每个进程设置优先级，优先级最高的程序先运行。


+ 多级队列
+ 最短进程优先
+ 保证调度
+ 彩票调度
+ 公平分享调度




3.2.1 地址空间
===============

把物理地址暴露给进程会带来许多问题。
比如进程可以修改操作系统，不同进程之间难以区分等等。

地址空间
    一个进程可用于寻址内存的一套地址集合。

每个进程都有一个自己独立的地址空间。

要实现地址空间，最简单的做法叫做动态重定位。
就是把每个进程的地址空间直接映射到物理内存的不同部分。




3.2.2 交换
============

当内存不足的时候，系统有两种处理策略。

交换（swapping）
    执行的时候，整个进程都在内存中。
    空闲的时候，进程的信息被存入硬盘，不会占用物理内存。


虚拟内存（virtual memory）
    执行的时候，程序只有一部分在内存中。



3.2.3 空闲内存管理
===================

在分配内存空间的时候，要记录内存的使用情况。
常见的方法有两种：位图和链表。

位图
    将内存划分为一个个单元，每个单元用一个 bit 表示，没占用为 0，占用为 1。

链表
    用链表记录被占用的和空闲的内存。

    要分配内存时，最简单的方法是首次适配（first fit），沿着链表，
    找到一个足够大的空间，就使用该空间。

    其他方法有下次适配、最佳适配、最差适配、快速适配。




3.3 虚拟内存
==============

虚拟内存的基本思想是，每个程序都有自己的地址空间，这个空间被分割成很多块，
每块都是也个页面（page）。每页都是一个连续的地址范围，会被映射到物理内存中。
实际执行程序的时候，只有必要的页面才会在如内存中，其余页面保存在硬盘。
如果程序引用到了硬盘中的页面，系统会将相应页面加载到内存中，
再重新执行失败的命令。


3.3.1 分页
===========

程序中使用的内存地址是虚拟地址（virtual address），
构成了一个虚拟地址空间（virtual address space）。
之后，由 MMU（memory management unit 内存管理单元）把虚拟地址映射为物理地址。

虚拟地址中的页面（page）对应于物理地址中的页框（page frame），
两者通常是一样大的。

当程序需要的页面不在物理内存中时，MMU 会发现没有和虚拟地址对应的映射，
然后就发生了缺页中断（page fault）。
系统会将一个很少使用的页框写入硬盘，然后将需要的页面载入到腾出来的页框里，
接着修改映射关系，最后继续执行程序。


3.3.2 页表
===========

页表（page table）用于把页面映射为页框。
每个虚拟地址空间都有个页表与之对应。

虚拟内存的本质是对物理内存的抽象，就像进程是对 CPU 的一种抽象。
虚拟内存的实现是将虚拟地址空间分解成页面，再通过页表，
将页面映射到页框。


3.3.3 加速分页
===============

主要考察两个问题：速度和大小。

每条指令都会对内存进行那么几次访问，因此页表的访问速度会成为整个指令的瓶颈。
另外，每个进程都有自己的页表，假设页长为 4K，电脑为 32 位，
那么一个地址空间就会有 100 万页，64 位更大。

大部分程序总是针对少量页面进行多次访问，也就是只有少量页表项会被反复读取，
而其他页表项很少被访问。
所以有专门的硬件（转换检测缓冲区，translation lookaside buffer，TLB），
直接将虚拟地址映射到物理地址，而不访问页表。



3.3.4 针对大内存的页表
=======================

TLB 可以加快虚拟地址到物理地址的转换，下面两种方法用于处理巨大的虚拟地址空间。

一种是多级页表，分级分得越多，就越灵活，同时也越复杂。
另一种是倒排页表，让每个页框拥有表，在这个表中记录对应的页面
（也就是将原来的键值对交换了位置）。





3.4 页面置换算法
=================

发生缺页中断的时候，系统要选择一个页面，将其替换。
页面置换算法研究的是如何选择页面。

在缓存的设计中，也需要考虑这种问题。

最优页面置换算法
    最理想，却无法实现的方法。
    记录每个页面在多少个指令之后会被访问，替换等待时间最长的页面。

NRU （not recently used，最近未使用）
    先淘汰那些被修改过，又没有访问的页面。

    好理解，好实现，性能够用。

FIFO （first-in first-out，先进先出）
    直接替换最早的页面。

    可能把常用页面直接替换掉。不会单独拿来用。

second chance，二次机会
    对 FIFO 的改进。仍然按照时间顺序来检查页面，不过会查看页面是否被使用。
    如果页面被使用，将页面移动到队列最后，检查下一个页面。
    直到碰上一个没被使用的页面，将其替换。

clock，时钟
    对 second chance 的改进，使用环形链表而不是普通链表。
    避免了移动页面的开销。

LRU （least recently used，最近最少使用）
    基于 *前几条指令中频繁访问某页面，那么后面的指令很可能也会访问该页面*
    这个实践经验，总结出了这么一种做法：
    发生缺页中断的时候，将访问时间间隔最久的页面给置换掉。

    实现比较麻烦，有专用硬件。

NFU （not frequently used，最不常用）
    LRU 的近似方案。为每个页面设置一个计数器，每次访问后更新计数器。
    计数器大体上能反映页面的访问频率。需要时，置换掉计数器最小的页面。

    性能不是很好。

aging，老化
    在对 NFU 做简单修改后，可以更好地模拟 LRU，称为老化（aging）算法。

    在更新计数器时，使用位移操作。每个周期都对全部计数器进行一次更新。
    有访问记录的右移一位，左边添加 1，没有访问记录的右移一位，左边添加 0。
    假设计数器有 8 位，那么就会记录 8 个周期的访问情况。
    替换的时候，直接将计数器最小的页面置换掉。

    良好的页面调度性能，可以有效实现。实际应用中最重要的算法之一。

工作集
    一个进程正在使用的页面的集合，成为工作集（working set）。

    这个算法的想法是淘汰那些不在工作集中的页面。

    实现起来开销较大。

WSClock，工作集时钟
    对工作集页面调度算法的改进，使用循环链表来实现。

    良好的页面调度性能，可以有效实现。实际应用中最重要的算法之一。
